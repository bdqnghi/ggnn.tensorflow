@Override
public boolean solvePositionConstraints(final SolverData data) {
    Vec2 cA = data.positions[m_indexA].c;
    float aA = data.positions[m_indexA].a;
    Vec2 cB = data.positions[m_indexB].c;
    float aB = data.positions[m_indexB].a;
    final Rot qA = pool.popRot();
    final Rot qB = pool.popRot();
    final Vec2 temp = pool.popVec2();
    final Vec2 rA = pool.popVec2();
    final Vec2 rB = pool.popVec2();
    qA.set(aA);
    qB.set(aB);
    float mA = m_invMassA, mB = m_invMassB;
    float iA = m_invIA, iB = m_invIB;
    Rot.mulToOutUnsafe(qA, temp.set(m_localAnchorA).subLocal(m_localCenterA), rA);
    Rot.mulToOutUnsafe(qB, temp.set(m_localAnchorB).subLocal(m_localCenterB), rB);
    float positionError, angularError;
    final Mat33 K = pool.popMat33();
    final Vec2 C1 = pool.popVec2();
    final Vec2 P = pool.popVec2();
    K.ex.x = mA + mB + rA.y * rA.y * iA + rB.y * rB.y * iB;
    K.ey.x = -rA.y * rA.x * iA - rB.y * rB.x * iB;
    K.ez.x = -rA.y * iA - rB.y * iB;
    K.ex.y = K.ey.x;
    K.ey.y = mA + mB + rA.x * rA.x * iA + rB.x * rB.x * iB;
    K.ez.y = rA.x * iA + rB.x * iB;
    K.ex.z = K.ez.x;
    K.ey.z = K.ez.y;
    K.ez.z = iA + iB;
    if (m_frequencyHz > 0.0f) {
        C1.set(cB).addLocal(rB).subLocal(cA).subLocal(rA);
        positionError = C1.length();
        angularError = 0.0f;
        K.solve22ToOut(C1, P);
        P.negateLocal();
        cA.x -= mA * P.x;
        cA.y -= mA * P.y;
        aA -= iA * Vec2.cross(rA, P);
        cB.x += mB * P.x;
        cB.y += mB * P.y;
        aB += iB * Vec2.cross(rB, P);
    } else {
        C1.set(cB).addLocal(rB).subLocal(cA).subLocal(rA);
        float C2 = aB - aA - m_referenceAngle;
        positionError = C1.length();
        angularError = MathUtils.abs(C2);
        final Vec3 C = pool.popVec3();
        final Vec3 impulse = pool.popVec3();
        C.set(C1.x, C1.y, C2);
        K.solve33ToOut(C, impulse);
        impulse.negateLocal();
        P.set(impulse.x, impulse.y);
        cA.x -= mA * P.x;
        cA.y -= mA * P.y;
        aA -= iA * (Vec2.cross(rA, P) + impulse.z);
        cB.x += mB * P.x;
        cB.y += mB * P.y;
        aB += iB * (Vec2.cross(rB, P) + impulse.z);
        pool.pushVec3(2);
    }
    // data.positions[m_indexA].c.set(cA);
    data.positions[m_indexA].a = aA;
    // data.positions[m_indexB].c.set(cB);
    data.positions[m_indexB].a = aB;
    pool.pushVec2(5);
    pool.pushRot(2);
    pool.pushMat33(1);
    return positionError <= Settings.linearSlop && angularError <= Settings.angularSlop;
}
